<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dynamic Graph Anomaly Detection — Data & Modeling Choices (Backend)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --card: #11161d;
      --text: #e7eef7;
      --muted: #9fb2c7;
      --accent: #7ac4ff;
      --chip: #1a222c;
      --green: #4ade80;
      --amber: #f59e0b;
      --red: #ef4444;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    html, body { background: var(--bg); color: var(--text); margin: 0; font-family: var(--sans); line-height: 1.5; }
    .wrap { max-width: 1000px; margin: 0 auto; padding: 32px 20px 96px; }
    header { margin-bottom: 28px; }
    h1 { font-size: 28px; margin: 0 0 8px; letter-spacing: .2px; }
    h2 { margin: 36px 0 8px; font-size: 20px; color: var(--accent); }
    h3 { margin: 24px 0 6px; font-size: 16px; color: var(--accent); }
    p { color: var(--muted); }
    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 12px; padding: 18px 18px; margin: 14px 0; }
    .grid { display: grid; gap: 14px; grid-template-columns: repeat(12, 1fr); }
    .col-6 { grid-column: span 6; }
    .col-12 { grid-column: span 12; }
    .chips { display:flex; flex-wrap: wrap; gap:8px; margin-top:8px; }
    .chip { background: var(--chip); border: 1px solid #233042; color: var(--text); padding: 4px 10px; border-radius: 999px; font-size: 12px; }
    code, pre { font-family: var(--mono); font-size: 13px; }
    pre { background: #0a0f15; color: var(--text); border:1px solid #1f2937; border-radius: 10px; padding: 14px; overflow: auto; box-shadow: inset 0 1px 0 rgba(255,255,255,.03); }
    kbd { font-family: var(--mono); background:#0f1720; border:1px solid #293548; border-radius:6px; padding:2px 6px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    ul { margin: 8px 0 8px 18px; }
    .toc a { color: var(--muted); }
    .muted { color: var(--muted); }
    .ok { color: var(--green); }
    .warn { color: var(--amber); }
    .crit { color: var(--red); }
    .footer { margin-top: 48px; font-size: 12px; color: var(--muted); }
    .hr { height:1px; background:#1f2937; margin: 22px 0; border:0; }
    @media (max-width: 900px) { .col-6 { grid-column: span 12; } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Dynamic Graph Anomaly Detection — Data & Modeling Choices (Backend)</h1>
      <p class="muted">This document details the <strong>data pipeline</strong>, modeling choices, and <strong>produced artifacts</strong> that power the anomaly detection prototype (node / edge / graph levels). It is intentionally UI-agnostic.</p>
      <div class="chips">
        <span class="chip">Unsupervised</span>
        <span class="chip">Event-windowed</span>
        <span class="chip">Node2Vec + Warm Start</span>
        <span class="chip">Procrustes Alignment</span>
        <span class="chip">Quantile Thresholds</span>
      </div>
    </header>

    <div class="card">
      <h2 id="at-a-glance">0) At a glance</h2>
      <ul>
        <li>Unsupervised anomaly detection on a <em>dynamic, heterogeneous</em> graph built from <code>add/delete</code> events.</li>
        <li>Event-count snapshots (1,000 events) → stable training & comparable steps.</li>
        <li>Node2Vec embeddings per snapshot, <em>warm-started</em> & aligned (Orthogonal Procrustes) → meaningful temporal drift.</li>
        <li>Edge anomalies: <strong>present-but-improbable</strong> and <strong>missing-but-expected</strong> (removed edges + KNN candidates).</li>
        <li>Graph-level score from JS(degree), Δcomponents, Δclustering.</li>
        <li>Node states & severities via per-snapshot quantiles → triage-ready.</li>
      </ul>
    </div>

    <div class="card toc">
      <h2>Contents</h2>
      <ul>
        <li><a href="#objective">Objective</a></li>
        <li><a href="#input">1) Input Data & Semantics</a></li>
        <li><a href="#snapshots">2) Snapshotting Strategy</a></li>
        <li><a href="#graph-build">3) Graph Construction</a></li>
        <li><a href="#embeddings">4) Node Representation Learning</a></li>
        <li><a href="#alignment">5) Temporal Alignment & Drift</a></li>
        <li><a href="#edges">6) Edge Anomalies</a></li>
        <li><a href="#graph">7) Graph-level Signal</a></li>
        <li><a href="#node-state">8) Node State Labeling</a></li>
        <li><a href="#outputs">9) Output Files & Schemas</a></li>
        <li><a href="#thresholds">10) Thresholds & Tunables</a></li>
        <li><a href="#rationale">11) Rationale & Trade-offs</a></li>
        <li><a href="#validation">12) Validation Suggestions</a></li>
      </ul>
    </div>

    <section id="objective">
      <h2>Objective</h2>
      <p>Unsupervised detection of anomalies at <strong>node</strong>, <strong>edge</strong>, and <strong>graph</strong> levels on a live, evolving knowledge graph. Produce interpretable, quantitative signals (scores, labels, metrics) for downstream explanation and triage.</p>
    </section>

    <section id="input">
      <h2>1) Input Data & Semantics</h2>
      <pre><code>src, dst, label, timestamp, event_type</code></pre>
      <ul>
        <li><code>event_type ∈ {add, delete}</code>; graph treated as <strong>undirected</strong> for topology (can switch to directed later).</li>
        <li><code>label</code> preserved as edge metadata (HAS_PORT, DEPENDS_ON, ...).</li>
        <li>Node type inferred from <code>node_id</code> prefix (e.g., <code>trunk-*</code>, <code>cpe-*</code>).</li>
      </ul>
      <p class="muted"><em>Why undirected?</em> For this MVP we focus on topology-driven drift and link plausibility; undirected simplifies degree, components, clustering, and Node2Vec behavior.</p>
    </section>

    <section id="snapshots">
      <h2>2) Snapshotting Strategy (Temporal Batching)</h2>
      <ul>
        <li><strong>Fixed event-count windows</strong> of <strong>1,000</strong> events → stable per-step signal and predictable training time.</li>
        <li>State at snapshot <code>t</code> = all events up to and including <code>t</code>, applied cumulatively.</li>
      </ul>
      <pre><code>data/snapshots/snapshot_0.csv ... snapshot_11.csv</code></pre>
    </section>

    <section id="graph-build">
      <h2>3) Graph Construction per Snapshot</h2>
      <ul>
        <li>Global <strong>stable node index</strong> via <code>data/embeddings/node_vocab.json</code> (<code>idx2id</code>, <code>id2idx</code>); new nodes append → monotonic indices.</li>
        <li>Undirected <code>edge_index</code> from canonicalized pairs <code>(min(u,v), max(u,v))</code>.</li>
        <li>Edge labels retained for neighbor/edge dumps.</li>
      </ul>
    </section>

    <section id="embeddings">
      <h2>4) Node Representation Learning (Per Snapshot)</h2>
      <ul>
        <li>Encoder: <strong>Node2Vec</strong> (PyTorch Geometric).</li>
        <li>Hyperparams: <code>dim=128</code>, <code>walk_length=20</code>, <code>walks_per_node=20</code>, <code>window=10</code>, <code>epochs=15</code>, <code>batch_size=1024</code>, <code>p=1.0</code>, <code>q=0.5</code>.</li>
        <li><strong>Warm-start</strong>: for <code>t&gt;0</code> we copy overlapping rows from <code>Z_{t-1}</code> to <code>Z_t</code> → faster convergence, smoother temporal behavior.</li>
      </ul>
      <pre><code>Artifacts per t:
- data/embeddings/Z_t.pt { "embeddings": FloatTensor[n_t, d] }
- data/embeddings/Z_t_preview.csv
- data/embeddings/node_vocab.json (global)</code></pre>
    </section>

    <section id="alignment">
      <h2>5) Temporal Alignment & Drift</h2>
      <ul>
        <li><strong>Orthogonal Procrustes</strong> aligns <code>Z_t</code> to <code>Z_{t-1}</code> over the common index range.</li>
        <li>Per-node <strong>drift</strong>: <code>|| (Z_t R_t)[i] - Z_{t-1}[i] ||_2</code> when node exists at both steps.</li>
        <li>Also compute <strong>degree</strong> at <code>t-1</code> and <code>t</code>; <code>Δdeg = deg_t - deg_{t-1}</code>, and <strong>novelty</strong>.</li>
      </ul>
    </section>

    <section id="edges">
      <h2>6) Edge Anomalies (Two Classes)</h2>
      <h3>A) Present-but-improbable</h3>
      <ul>
        <li>Candidate: edges in <code>E_t</code>.</li>
        <li>Score: link probability <code>p(u,v)</code> from embedding similarity (cosine/dot → normalization/sigmoid).</li>
        <li>Decision: flag if <code>p(u,v) ≤ τ_present</code> (default 0.15). Sort ascending by <code>p</code>.</li>
      </ul>

      <h3>B) Missing-but-expected</h3>
      <ul>
        <li><strong>Removed edges</strong> between <code>t-1</code> and <code>t</code>: treat as highly expected (<code>source="removed_edge"</code>), assign <code>p=1.0</code>.</li>
        <li><strong>KNN candidates</strong>: top-k nearest neighbors per node (excluding existing edges), <code>source="knn_candidate"</code>, score via same <code>p(u,v)</code>.</li>
        <li>Decision: flag if <code>p(u,v) ≥ τ_missing</code> (default 0.98). Cap candidate volume.</li>
      </ul>

      <pre><code>edges_t.json (example)
{
  "src": "trunk-802ae17d",
  "dst": "concentrator-6b1ad12b",
  "edge_type": "DEPENDS_ON",
  "status": "missing_but_expected",
  "source": "removed_edge",
  "probability": 1.0,
  "anomaly_score": 1.0
}</code></pre>
    </section>

    <section id="graph">
      <h2>7) Graph-level Anomaly Signal</h2>
      <ul>
        <li>JS divergence of degree distributions, Δ connected components, Δ global clustering.</li>
        <li>Blend (after normalization) → <strong>graph anomaly score</strong> ∈ [0,1] for timeline spikes.</li>
      </ul>
      <pre><code>graph_series.json → [ { snapshot, graph_anomaly_score, metrics, summary }, ... ]</code></pre>
    </section>

    <section id="node-state">
      <h2>8) Node State Labeling (Quantile-based)</h2>
      <h3>State</h3>
      <ul>
        <li><code>isolated</code>: <code>deg_{t-1}&gt;0</code> and <code>deg_t=0</code></li>
        <li><code>new</code>: appears at <code>t</code></li>
        <li><code>reconfigured</code>: <code>drift ≥ q90(drift)</code> or <code>|Δdeg| ≥ q90(|Δdeg|)</code></li>
        <li><code>stable</code>: otherwise</li>
      </ul>
      <h3>Severity</h3>
      <ul>
        <li><code>critical</code>: isolated OR <code>removed_edges_count ≥ q90</code> OR <code>|Δdeg| ≥ q95</code> OR <code>drift ≥ q95</code></li>
        <li><code>warning</code>: reconfigured OR (new &amp; <code>deg_t ≥ q90(deg)</code>) OR <code>removed_edges_count ≥ q75</code></li>
        <li><code>info</code>: otherwise</li>
      </ul>

      <pre><code>node_state_t.json (example)
{
  "node_id": "trunk-802ae17d",
  "node_type": "trunk",
  "degree_prev": 265,
  "degree": 67,
  "degree_change": -198,
  "drift": 2.27,
  "novelty": false,
  "removed_edges_count": 200,
  "state": "reconfigured",
  "severity": "critical",
  "anomaly_score": 0.93
}</code></pre>
    </section>

    <section id="outputs">
      <h2>9) Output Files & Schemas</h2>
      <pre><code>Per snapshot t
- data/embeddings/Z_t.pt (tensor) & Z_t_preview.csv
- data/outputs/node_state_t.json  (preferred rich per-node)
- data/outputs/nodes_t.json       (fallback simple top list)
- data/outputs/edges_t.json       (present/missing anomalies)
- data/outputs/report_t.json      (unified snapshot report)
Across snapshots
- data/outputs/graph_series.json  (timeline)
On-demand
- neighbors_t_{node}.json, node_trend_{node}.json, edge_history_{src}__{dst}.json</code></pre>
    </section>

    <section id="thresholds">
      <h2>10) Thresholds & Tunables (CLI)</h2>
      <ul>
        <li>Event window size (default 1000)</li>
        <li>Node2Vec: <code>dim, walk_length, walks_per_node, window, epochs, batch_size, p, q</code></li>
        <li>Edges: <code>τ_present</code> (default 0.15), <code>τ_missing</code> (0.98), <code>knn</code>, <code>max_missing_candidates</code></li>
        <li>Node state quantiles: p75/p90/p95</li>
      </ul>
    </section>

    <section id="rationale">
      <h2>11) Rationale & Trade-offs</h2>
      <ul>
        <li>Unsupervised: quantiles + similarity priors → label-free.</li>
        <li>Event windows: stable per-step signal and training time.</li>
        <li>Node2Vec + warm-start + Procrustes: simple, GPU-fast, temporally smooth drift.</li>
        <li>Removed-edge emphasis: operationally relevant incidents rise to the top.</li>
      </ul>
      <p class="muted">Limitations / next steps: trained link decoder; directionality & relation-types; per-type calibration; online/incremental updates.</p>
    </section>

    <section id="validation">
      <h2>12) Validation Suggestions (for Math/ML)</h2>
      <ul>
        <li>Drift vs |Δdeg| correlation sanity checks.</li>
        <li>JS(degree) spikes vs removed-edge counts over time.</li>
        <li>Per-type calibrations (trunk vs cpe vs agreement).</li>
        <li>Ablations: vary Node2Vec <code>p,q</code>; compare cosine vs dot+sigmoid for <code>p(u,v)</code>.</li>
        <li>Tune <code>τ_present</code>, <code>τ_missing</code>, and quantiles (p90→p95) for desired prevalence.</li>
      </ul>
    </section>

    <div class="footer">
      <div class="hr"></div>
      <p>© Mine the Gap — Hackathon prototype. This HTML is self-contained and GitHub-pages friendly.</p>
    </div>
  </div>
</body>
</html>
